{"ast":null,"code":"import { __assign, __read } from './_virtual/_tslib.js';\nimport { IS_PRODUCTION } from './environment.js';\nimport { toSCXMLEvent, isFunction, toEventObject, getEventType, isString, partition, updateContext, flatten, toArray, toGuard, evaluateGuard, warn, isArray } from './utils.js';\nimport { SpecialTargets, ActionTypes } from './types.js';\nimport { send as send$1, update, assign as assign$1, init, raise as raise$1, log as log$1, cancel as cancel$1, error as error$1, stop as stop$1, pure as pure$1, choose as choose$1 } from './actionTypes.js';\nvar initEvent = /*#__PURE__*/toSCXMLEvent({\n  type: init\n});\n\nfunction getActionFunction(actionType, actionFunctionMap) {\n  return actionFunctionMap ? actionFunctionMap[actionType] || undefined : undefined;\n}\n\nfunction toActionObject(action, actionFunctionMap) {\n  var actionObject;\n\n  if (isString(action) || typeof action === 'number') {\n    var exec = getActionFunction(action, actionFunctionMap);\n\n    if (isFunction(exec)) {\n      actionObject = {\n        type: action,\n        exec: exec\n      };\n    } else if (exec) {\n      actionObject = exec;\n    } else {\n      actionObject = {\n        type: action,\n        exec: undefined\n      };\n    }\n  } else if (isFunction(action)) {\n    actionObject = {\n      // Convert action to string if unnamed\n      type: action.name || action.toString(),\n      exec: action\n    };\n  } else {\n    var exec = getActionFunction(action.type, actionFunctionMap);\n\n    if (isFunction(exec)) {\n      actionObject = __assign(__assign({}, action), {\n        exec: exec\n      });\n    } else if (exec) {\n      var actionType = exec.type || action.type;\n      actionObject = __assign(__assign(__assign({}, exec), action), {\n        type: actionType\n      });\n    } else {\n      actionObject = action;\n    }\n  }\n\n  Object.defineProperty(actionObject, 'toString', {\n    value: function () {\n      return actionObject.type;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return actionObject;\n}\n\nvar toActionObjects = function (action, actionFunctionMap) {\n  if (!action) {\n    return [];\n  }\n\n  var actions = isArray(action) ? action : [action];\n  return actions.map(function (subAction) {\n    return toActionObject(subAction, actionFunctionMap);\n  });\n};\n\nfunction toActivityDefinition(action) {\n  var actionObject = toActionObject(action);\n  return __assign(__assign({\n    id: isString(action) ? action : actionObject.id\n  }, actionObject), {\n    type: actionObject.type\n  });\n}\n/**\r\n * Raises an event. This places the event in the internal event queue, so that\r\n * the event is immediately consumed by the machine in the current step.\r\n *\r\n * @param eventType The event to raise.\r\n */\n\n\nfunction raise(event) {\n  if (!isString(event)) {\n    return send(event, {\n      to: SpecialTargets.Internal\n    });\n  }\n\n  return {\n    type: raise$1,\n    event: event\n  };\n}\n\nfunction resolveRaise(action) {\n  return {\n    type: raise$1,\n    _event: toSCXMLEvent(action.event)\n  };\n}\n/**\r\n * Sends an event. This returns an action that will be read by an interpreter to\r\n * send the event in the next step, after the current step is finished executing.\r\n *\r\n * @param event The event to send.\r\n * @param options Options to pass into the send event:\r\n *  - `id` - The unique send event identifier (used with `cancel()`).\r\n *  - `delay` - The number of milliseconds to delay the sending of the event.\r\n *  - `to` - The target of this event (by default, the machine the event was sent from).\r\n */\n\n\nfunction send(event, options) {\n  return {\n    to: options ? options.to : undefined,\n    type: send$1,\n    event: isFunction(event) ? event : toEventObject(event),\n    delay: options ? options.delay : undefined,\n    id: options && options.id !== undefined ? options.id : isFunction(event) ? event.name : getEventType(event)\n  };\n}\n\nfunction resolveSend(action, ctx, _event, delaysMap) {\n  var meta = {\n    _event: _event\n  }; // TODO: helper function for resolving Expr\n\n  var resolvedEvent = toSCXMLEvent(isFunction(action.event) ? action.event(ctx, _event.data, meta) : action.event);\n  var resolvedDelay;\n\n  if (isString(action.delay)) {\n    var configDelay = delaysMap && delaysMap[action.delay];\n    resolvedDelay = isFunction(configDelay) ? configDelay(ctx, _event.data, meta) : configDelay;\n  } else {\n    resolvedDelay = isFunction(action.delay) ? action.delay(ctx, _event.data, meta) : action.delay;\n  }\n\n  var resolvedTarget = isFunction(action.to) ? action.to(ctx, _event.data, meta) : action.to;\n  return __assign(__assign({}, action), {\n    to: resolvedTarget,\n    _event: resolvedEvent,\n    event: resolvedEvent.data,\n    delay: resolvedDelay\n  });\n}\n/**\r\n * Sends an event to this machine's parent.\r\n *\r\n * @param event The event to send to the parent machine.\r\n * @param options Options to pass into the send event.\r\n */\n\n\nfunction sendParent(event, options) {\n  return send(event, __assign(__assign({}, options), {\n    to: SpecialTargets.Parent\n  }));\n}\n/**\r\n * Sends an update event to this machine's parent.\r\n */\n\n\nfunction sendUpdate() {\n  return sendParent(update);\n}\n/**\r\n * Sends an event back to the sender of the original event.\r\n *\r\n * @param event The event to send back to the sender\r\n * @param options Options to pass into the send event\r\n */\n\n\nfunction respond(event, options) {\n  return send(event, __assign(__assign({}, options), {\n    to: function (_, __, _a) {\n      var _event = _a._event;\n      return _event.origin; // TODO: handle when _event.origin is undefined\n    }\n  }));\n}\n\nvar defaultLogExpr = function (context, event) {\n  return {\n    context: context,\n    event: event\n  };\n};\n/**\r\n *\r\n * @param expr The expression function to evaluate which will be logged.\r\n *  Takes in 2 arguments:\r\n *  - `ctx` - the current state context\r\n *  - `event` - the event that caused this action to be executed.\r\n * @param label The label to give to the logged expression.\r\n */\n\n\nfunction log(expr, label) {\n  if (expr === void 0) {\n    expr = defaultLogExpr;\n  }\n\n  return {\n    type: log$1,\n    label: label,\n    expr: expr\n  };\n}\n\nvar resolveLog = function (action, ctx, _event) {\n  return __assign(__assign({}, action), {\n    value: isString(action.expr) ? action.expr : action.expr(ctx, _event.data, {\n      _event: _event\n    })\n  });\n};\n/**\r\n * Cancels an in-flight `send(...)` action. A canceled sent action will not\r\n * be executed, nor will its event be sent, unless it has already been sent\r\n * (e.g., if `cancel(...)` is called after the `send(...)` action's `delay`).\r\n *\r\n * @param sendId The `id` of the `send(...)` action to cancel.\r\n */\n\n\nvar cancel = function (sendId) {\n  return {\n    type: cancel$1,\n    sendId: sendId\n  };\n};\n/**\r\n * Starts an activity.\r\n *\r\n * @param activity The activity to start.\r\n */\n\n\nfunction start(activity) {\n  var activityDef = toActivityDefinition(activity);\n  return {\n    type: ActionTypes.Start,\n    activity: activityDef,\n    exec: undefined\n  };\n}\n/**\r\n * Stops an activity.\r\n *\r\n * @param actorRef The activity to stop.\r\n */\n\n\nfunction stop(actorRef) {\n  var activity = isFunction(actorRef) ? actorRef : toActivityDefinition(actorRef);\n  return {\n    type: ActionTypes.Stop,\n    activity: activity,\n    exec: undefined\n  };\n}\n\nfunction resolveStop(action, context, _event) {\n  var actorRefOrString = isFunction(action.activity) ? action.activity(context, _event.data) : action.activity;\n  var resolvedActorRef = typeof actorRefOrString === 'string' ? {\n    id: actorRefOrString\n  } : actorRefOrString;\n  var actionObject = {\n    type: ActionTypes.Stop,\n    activity: resolvedActorRef\n  };\n  return actionObject;\n}\n/**\r\n * Updates the current context of the machine.\r\n *\r\n * @param assignment An object that represents the partial context to update.\r\n */\n\n\nvar assign = function (assignment) {\n  return {\n    type: assign$1,\n    assignment: assignment\n  };\n};\n/**\r\n * Returns an event type that represents an implicit event that\r\n * is sent after the specified `delay`.\r\n *\r\n * @param delayRef The delay in milliseconds\r\n * @param id The state node ID where this event is handled\r\n */\n\n\nfunction after(delayRef, id) {\n  var idSuffix = id ? \"#\" + id : '';\n  return ActionTypes.After + \"(\" + delayRef + \")\" + idSuffix;\n}\n/**\r\n * Returns an event that represents that a final state node\r\n * has been reached in the parent state node.\r\n *\r\n * @param id The final state node's parent state node `id`\r\n * @param data The data to pass into the event\r\n */\n\n\nfunction done(id, data) {\n  var type = ActionTypes.DoneState + \".\" + id;\n  var eventObject = {\n    type: type,\n    data: data\n  };\n\n  eventObject.toString = function () {\n    return type;\n  };\n\n  return eventObject;\n}\n/**\r\n * Returns an event that represents that an invoked service has terminated.\r\n *\r\n * An invoked service is terminated when it has reached a top-level final state node,\r\n * but not when it is canceled.\r\n *\r\n * @param id The final state node ID\r\n * @param data The data to pass into the event\r\n */\n\n\nfunction doneInvoke(id, data) {\n  var type = ActionTypes.DoneInvoke + \".\" + id;\n  var eventObject = {\n    type: type,\n    data: data\n  };\n\n  eventObject.toString = function () {\n    return type;\n  };\n\n  return eventObject;\n}\n\nfunction error(id, data) {\n  var type = ActionTypes.ErrorPlatform + \".\" + id;\n  var eventObject = {\n    type: type,\n    data: data\n  };\n\n  eventObject.toString = function () {\n    return type;\n  };\n\n  return eventObject;\n}\n\nfunction pure(getActions) {\n  return {\n    type: ActionTypes.Pure,\n    get: getActions\n  };\n}\n/**\r\n * Forwards (sends) an event to a specified service.\r\n *\r\n * @param target The target service to forward the event to.\r\n * @param options Options to pass into the send action creator.\r\n */\n\n\nfunction forwardTo(target, options) {\n  return send(function (_, event) {\n    return event;\n  }, __assign(__assign({}, options), {\n    to: target\n  }));\n}\n/**\r\n * Escalates an error by sending it as an event to this machine's parent.\r\n *\r\n * @param errorData The error data to send, or the expression function that\r\n * takes in the `context`, `event`, and `meta`, and returns the error data to send.\r\n * @param options Options to pass into the send action creator.\r\n */\n\n\nfunction escalate(errorData, options) {\n  return sendParent(function (context, event, meta) {\n    return {\n      type: error$1,\n      data: isFunction(errorData) ? errorData(context, event, meta) : errorData\n    };\n  }, __assign(__assign({}, options), {\n    to: SpecialTargets.Parent\n  }));\n}\n\nfunction choose(conds) {\n  return {\n    type: ActionTypes.Choose,\n    conds: conds\n  };\n}\n\nfunction resolveActions(machine, currentState, currentContext, _event, actions) {\n  var _a = __read(partition(actions, function (action) {\n    return action.type === assign$1;\n  }), 2),\n      assignActions = _a[0],\n      otherActions = _a[1];\n\n  var updatedContext = assignActions.length ? updateContext(currentContext, _event, assignActions, currentState) : currentContext;\n  var resolvedActions = flatten(otherActions.map(function (actionObject) {\n    var _a;\n\n    switch (actionObject.type) {\n      case raise$1:\n        return resolveRaise(actionObject);\n\n      case send$1:\n        var sendAction = resolveSend(actionObject, updatedContext, _event, machine.options.delays); // TODO: fix ActionTypes.Init\n\n        if (!IS_PRODUCTION) {\n          // warn after resolving as we can create better contextual message here\n          warn(!isString(actionObject.delay) || typeof sendAction.delay === 'number', // tslint:disable-next-line:max-line-length\n          \"No delay reference for delay expression '\" + actionObject.delay + \"' was found on machine '\" + machine.id + \"'\");\n        }\n\n        return sendAction;\n\n      case log$1:\n        return resolveLog(actionObject, updatedContext, _event);\n\n      case choose$1:\n        {\n          var chooseAction = actionObject;\n          var matchedActions = (_a = chooseAction.conds.find(function (condition) {\n            var guard = toGuard(condition.cond, machine.options.guards);\n            return !guard || evaluateGuard(machine, guard, updatedContext, _event, currentState);\n          })) === null || _a === void 0 ? void 0 : _a.actions;\n\n          if (!matchedActions) {\n            return [];\n          }\n\n          var resolved = resolveActions(machine, currentState, updatedContext, _event, toActionObjects(toArray(matchedActions), machine.options.actions));\n          updatedContext = resolved[1];\n          return resolved[0];\n        }\n\n      case pure$1:\n        {\n          var matchedActions = actionObject.get(updatedContext, _event.data);\n\n          if (!matchedActions) {\n            return [];\n          }\n\n          var resolved = resolveActions(machine, currentState, updatedContext, _event, toActionObjects(toArray(matchedActions), machine.options.actions));\n          updatedContext = resolved[1];\n          return resolved[0];\n        }\n\n      case stop$1:\n        {\n          return resolveStop(actionObject, updatedContext, _event);\n        }\n\n      default:\n        return toActionObject(actionObject, machine.options.actions);\n    }\n  }));\n  return [resolvedActions, updatedContext];\n}\n\nexport { after, assign, cancel, choose, done, doneInvoke, error, escalate, forwardTo, getActionFunction, initEvent, log, pure, raise, resolveActions, resolveLog, resolveRaise, resolveSend, resolveStop, respond, send, sendParent, sendUpdate, start, stop, toActionObject, toActionObjects, toActivityDefinition };","map":{"version":3,"sources":["/Users/trent/Sites/landlines_map/node_modules/xstate/es/actions.js"],"names":["__assign","__read","IS_PRODUCTION","toSCXMLEvent","isFunction","toEventObject","getEventType","isString","partition","updateContext","flatten","toArray","toGuard","evaluateGuard","warn","isArray","SpecialTargets","ActionTypes","send","send$1","update","assign","assign$1","init","raise","raise$1","log","log$1","cancel","cancel$1","error","error$1","stop","stop$1","pure","pure$1","choose","choose$1","initEvent","type","getActionFunction","actionType","actionFunctionMap","undefined","toActionObject","action","actionObject","exec","name","toString","Object","defineProperty","value","enumerable","configurable","toActionObjects","actions","map","subAction","toActivityDefinition","id","event","to","Internal","resolveRaise","_event","options","delay","resolveSend","ctx","delaysMap","meta","resolvedEvent","data","resolvedDelay","configDelay","resolvedTarget","sendParent","Parent","sendUpdate","respond","_","__","_a","origin","defaultLogExpr","context","expr","label","resolveLog","sendId","start","activity","activityDef","Start","actorRef","Stop","resolveStop","actorRefOrString","resolvedActorRef","assignment","after","delayRef","idSuffix","After","done","DoneState","eventObject","doneInvoke","DoneInvoke","ErrorPlatform","getActions","Pure","get","forwardTo","target","escalate","errorData","conds","Choose","resolveActions","machine","currentState","currentContext","assignActions","otherActions","updatedContext","length","resolvedActions","sendAction","delays","chooseAction","matchedActions","find","condition","guard","cond","guards","resolved"],"mappings":"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","sourcesContent":["import { __assign, __read } from './_virtual/_tslib.js';\nimport { IS_PRODUCTION } from './environment.js';\nimport { toSCXMLEvent, isFunction, toEventObject, getEventType, isString, partition, updateContext, flatten, toArray, toGuard, evaluateGuard, warn, isArray } from './utils.js';\nimport { SpecialTargets, ActionTypes } from './types.js';\nimport { send as send$1, update, assign as assign$1, init, raise as raise$1, log as log$1, cancel as cancel$1, error as error$1, stop as stop$1, pure as pure$1, choose as choose$1 } from './actionTypes.js';\nvar initEvent = /*#__PURE__*/toSCXMLEvent({\n  type: init\n});\n\nfunction getActionFunction(actionType, actionFunctionMap) {\n  return actionFunctionMap ? actionFunctionMap[actionType] || undefined : undefined;\n}\n\nfunction toActionObject(action, actionFunctionMap) {\n  var actionObject;\n\n  if (isString(action) || typeof action === 'number') {\n    var exec = getActionFunction(action, actionFunctionMap);\n\n    if (isFunction(exec)) {\n      actionObject = {\n        type: action,\n        exec: exec\n      };\n    } else if (exec) {\n      actionObject = exec;\n    } else {\n      actionObject = {\n        type: action,\n        exec: undefined\n      };\n    }\n  } else if (isFunction(action)) {\n    actionObject = {\n      // Convert action to string if unnamed\n      type: action.name || action.toString(),\n      exec: action\n    };\n  } else {\n    var exec = getActionFunction(action.type, actionFunctionMap);\n\n    if (isFunction(exec)) {\n      actionObject = __assign(__assign({}, action), {\n        exec: exec\n      });\n    } else if (exec) {\n      var actionType = exec.type || action.type;\n      actionObject = __assign(__assign(__assign({}, exec), action), {\n        type: actionType\n      });\n    } else {\n      actionObject = action;\n    }\n  }\n\n  Object.defineProperty(actionObject, 'toString', {\n    value: function () {\n      return actionObject.type;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return actionObject;\n}\n\nvar toActionObjects = function (action, actionFunctionMap) {\n  if (!action) {\n    return [];\n  }\n\n  var actions = isArray(action) ? action : [action];\n  return actions.map(function (subAction) {\n    return toActionObject(subAction, actionFunctionMap);\n  });\n};\n\nfunction toActivityDefinition(action) {\n  var actionObject = toActionObject(action);\n  return __assign(__assign({\n    id: isString(action) ? action : actionObject.id\n  }, actionObject), {\n    type: actionObject.type\n  });\n}\n/**\r\n * Raises an event. This places the event in the internal event queue, so that\r\n * the event is immediately consumed by the machine in the current step.\r\n *\r\n * @param eventType The event to raise.\r\n */\n\n\nfunction raise(event) {\n  if (!isString(event)) {\n    return send(event, {\n      to: SpecialTargets.Internal\n    });\n  }\n\n  return {\n    type: raise$1,\n    event: event\n  };\n}\n\nfunction resolveRaise(action) {\n  return {\n    type: raise$1,\n    _event: toSCXMLEvent(action.event)\n  };\n}\n/**\r\n * Sends an event. This returns an action that will be read by an interpreter to\r\n * send the event in the next step, after the current step is finished executing.\r\n *\r\n * @param event The event to send.\r\n * @param options Options to pass into the send event:\r\n *  - `id` - The unique send event identifier (used with `cancel()`).\r\n *  - `delay` - The number of milliseconds to delay the sending of the event.\r\n *  - `to` - The target of this event (by default, the machine the event was sent from).\r\n */\n\n\nfunction send(event, options) {\n  return {\n    to: options ? options.to : undefined,\n    type: send$1,\n    event: isFunction(event) ? event : toEventObject(event),\n    delay: options ? options.delay : undefined,\n    id: options && options.id !== undefined ? options.id : isFunction(event) ? event.name : getEventType(event)\n  };\n}\n\nfunction resolveSend(action, ctx, _event, delaysMap) {\n  var meta = {\n    _event: _event\n  }; // TODO: helper function for resolving Expr\n\n  var resolvedEvent = toSCXMLEvent(isFunction(action.event) ? action.event(ctx, _event.data, meta) : action.event);\n  var resolvedDelay;\n\n  if (isString(action.delay)) {\n    var configDelay = delaysMap && delaysMap[action.delay];\n    resolvedDelay = isFunction(configDelay) ? configDelay(ctx, _event.data, meta) : configDelay;\n  } else {\n    resolvedDelay = isFunction(action.delay) ? action.delay(ctx, _event.data, meta) : action.delay;\n  }\n\n  var resolvedTarget = isFunction(action.to) ? action.to(ctx, _event.data, meta) : action.to;\n  return __assign(__assign({}, action), {\n    to: resolvedTarget,\n    _event: resolvedEvent,\n    event: resolvedEvent.data,\n    delay: resolvedDelay\n  });\n}\n/**\r\n * Sends an event to this machine's parent.\r\n *\r\n * @param event The event to send to the parent machine.\r\n * @param options Options to pass into the send event.\r\n */\n\n\nfunction sendParent(event, options) {\n  return send(event, __assign(__assign({}, options), {\n    to: SpecialTargets.Parent\n  }));\n}\n/**\r\n * Sends an update event to this machine's parent.\r\n */\n\n\nfunction sendUpdate() {\n  return sendParent(update);\n}\n/**\r\n * Sends an event back to the sender of the original event.\r\n *\r\n * @param event The event to send back to the sender\r\n * @param options Options to pass into the send event\r\n */\n\n\nfunction respond(event, options) {\n  return send(event, __assign(__assign({}, options), {\n    to: function (_, __, _a) {\n      var _event = _a._event;\n      return _event.origin; // TODO: handle when _event.origin is undefined\n    }\n  }));\n}\n\nvar defaultLogExpr = function (context, event) {\n  return {\n    context: context,\n    event: event\n  };\n};\n/**\r\n *\r\n * @param expr The expression function to evaluate which will be logged.\r\n *  Takes in 2 arguments:\r\n *  - `ctx` - the current state context\r\n *  - `event` - the event that caused this action to be executed.\r\n * @param label The label to give to the logged expression.\r\n */\n\n\nfunction log(expr, label) {\n  if (expr === void 0) {\n    expr = defaultLogExpr;\n  }\n\n  return {\n    type: log$1,\n    label: label,\n    expr: expr\n  };\n}\n\nvar resolveLog = function (action, ctx, _event) {\n  return __assign(__assign({}, action), {\n    value: isString(action.expr) ? action.expr : action.expr(ctx, _event.data, {\n      _event: _event\n    })\n  });\n};\n/**\r\n * Cancels an in-flight `send(...)` action. A canceled sent action will not\r\n * be executed, nor will its event be sent, unless it has already been sent\r\n * (e.g., if `cancel(...)` is called after the `send(...)` action's `delay`).\r\n *\r\n * @param sendId The `id` of the `send(...)` action to cancel.\r\n */\n\n\nvar cancel = function (sendId) {\n  return {\n    type: cancel$1,\n    sendId: sendId\n  };\n};\n/**\r\n * Starts an activity.\r\n *\r\n * @param activity The activity to start.\r\n */\n\n\nfunction start(activity) {\n  var activityDef = toActivityDefinition(activity);\n  return {\n    type: ActionTypes.Start,\n    activity: activityDef,\n    exec: undefined\n  };\n}\n/**\r\n * Stops an activity.\r\n *\r\n * @param actorRef The activity to stop.\r\n */\n\n\nfunction stop(actorRef) {\n  var activity = isFunction(actorRef) ? actorRef : toActivityDefinition(actorRef);\n  return {\n    type: ActionTypes.Stop,\n    activity: activity,\n    exec: undefined\n  };\n}\n\nfunction resolveStop(action, context, _event) {\n  var actorRefOrString = isFunction(action.activity) ? action.activity(context, _event.data) : action.activity;\n  var resolvedActorRef = typeof actorRefOrString === 'string' ? {\n    id: actorRefOrString\n  } : actorRefOrString;\n  var actionObject = {\n    type: ActionTypes.Stop,\n    activity: resolvedActorRef\n  };\n  return actionObject;\n}\n/**\r\n * Updates the current context of the machine.\r\n *\r\n * @param assignment An object that represents the partial context to update.\r\n */\n\n\nvar assign = function (assignment) {\n  return {\n    type: assign$1,\n    assignment: assignment\n  };\n};\n/**\r\n * Returns an event type that represents an implicit event that\r\n * is sent after the specified `delay`.\r\n *\r\n * @param delayRef The delay in milliseconds\r\n * @param id The state node ID where this event is handled\r\n */\n\n\nfunction after(delayRef, id) {\n  var idSuffix = id ? \"#\" + id : '';\n  return ActionTypes.After + \"(\" + delayRef + \")\" + idSuffix;\n}\n/**\r\n * Returns an event that represents that a final state node\r\n * has been reached in the parent state node.\r\n *\r\n * @param id The final state node's parent state node `id`\r\n * @param data The data to pass into the event\r\n */\n\n\nfunction done(id, data) {\n  var type = ActionTypes.DoneState + \".\" + id;\n  var eventObject = {\n    type: type,\n    data: data\n  };\n\n  eventObject.toString = function () {\n    return type;\n  };\n\n  return eventObject;\n}\n/**\r\n * Returns an event that represents that an invoked service has terminated.\r\n *\r\n * An invoked service is terminated when it has reached a top-level final state node,\r\n * but not when it is canceled.\r\n *\r\n * @param id The final state node ID\r\n * @param data The data to pass into the event\r\n */\n\n\nfunction doneInvoke(id, data) {\n  var type = ActionTypes.DoneInvoke + \".\" + id;\n  var eventObject = {\n    type: type,\n    data: data\n  };\n\n  eventObject.toString = function () {\n    return type;\n  };\n\n  return eventObject;\n}\n\nfunction error(id, data) {\n  var type = ActionTypes.ErrorPlatform + \".\" + id;\n  var eventObject = {\n    type: type,\n    data: data\n  };\n\n  eventObject.toString = function () {\n    return type;\n  };\n\n  return eventObject;\n}\n\nfunction pure(getActions) {\n  return {\n    type: ActionTypes.Pure,\n    get: getActions\n  };\n}\n/**\r\n * Forwards (sends) an event to a specified service.\r\n *\r\n * @param target The target service to forward the event to.\r\n * @param options Options to pass into the send action creator.\r\n */\n\n\nfunction forwardTo(target, options) {\n  return send(function (_, event) {\n    return event;\n  }, __assign(__assign({}, options), {\n    to: target\n  }));\n}\n/**\r\n * Escalates an error by sending it as an event to this machine's parent.\r\n *\r\n * @param errorData The error data to send, or the expression function that\r\n * takes in the `context`, `event`, and `meta`, and returns the error data to send.\r\n * @param options Options to pass into the send action creator.\r\n */\n\n\nfunction escalate(errorData, options) {\n  return sendParent(function (context, event, meta) {\n    return {\n      type: error$1,\n      data: isFunction(errorData) ? errorData(context, event, meta) : errorData\n    };\n  }, __assign(__assign({}, options), {\n    to: SpecialTargets.Parent\n  }));\n}\n\nfunction choose(conds) {\n  return {\n    type: ActionTypes.Choose,\n    conds: conds\n  };\n}\n\nfunction resolveActions(machine, currentState, currentContext, _event, actions) {\n  var _a = __read(partition(actions, function (action) {\n    return action.type === assign$1;\n  }), 2),\n      assignActions = _a[0],\n      otherActions = _a[1];\n\n  var updatedContext = assignActions.length ? updateContext(currentContext, _event, assignActions, currentState) : currentContext;\n  var resolvedActions = flatten(otherActions.map(function (actionObject) {\n    var _a;\n\n    switch (actionObject.type) {\n      case raise$1:\n        return resolveRaise(actionObject);\n\n      case send$1:\n        var sendAction = resolveSend(actionObject, updatedContext, _event, machine.options.delays); // TODO: fix ActionTypes.Init\n\n        if (!IS_PRODUCTION) {\n          // warn after resolving as we can create better contextual message here\n          warn(!isString(actionObject.delay) || typeof sendAction.delay === 'number', // tslint:disable-next-line:max-line-length\n          \"No delay reference for delay expression '\" + actionObject.delay + \"' was found on machine '\" + machine.id + \"'\");\n        }\n\n        return sendAction;\n\n      case log$1:\n        return resolveLog(actionObject, updatedContext, _event);\n\n      case choose$1:\n        {\n          var chooseAction = actionObject;\n          var matchedActions = (_a = chooseAction.conds.find(function (condition) {\n            var guard = toGuard(condition.cond, machine.options.guards);\n            return !guard || evaluateGuard(machine, guard, updatedContext, _event, currentState);\n          })) === null || _a === void 0 ? void 0 : _a.actions;\n\n          if (!matchedActions) {\n            return [];\n          }\n\n          var resolved = resolveActions(machine, currentState, updatedContext, _event, toActionObjects(toArray(matchedActions), machine.options.actions));\n          updatedContext = resolved[1];\n          return resolved[0];\n        }\n\n      case pure$1:\n        {\n          var matchedActions = actionObject.get(updatedContext, _event.data);\n\n          if (!matchedActions) {\n            return [];\n          }\n\n          var resolved = resolveActions(machine, currentState, updatedContext, _event, toActionObjects(toArray(matchedActions), machine.options.actions));\n          updatedContext = resolved[1];\n          return resolved[0];\n        }\n\n      case stop$1:\n        {\n          return resolveStop(actionObject, updatedContext, _event);\n        }\n\n      default:\n        return toActionObject(actionObject, machine.options.actions);\n    }\n  }));\n  return [resolvedActions, updatedContext];\n}\n\nexport { after, assign, cancel, choose, done, doneInvoke, error, escalate, forwardTo, getActionFunction, initEvent, log, pure, raise, resolveActions, resolveLog, resolveRaise, resolveSend, resolveStop, respond, send, sendParent, sendUpdate, start, stop, toActionObject, toActionObjects, toActivityDefinition };"]},"metadata":{},"sourceType":"module"}